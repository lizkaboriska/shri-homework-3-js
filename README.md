# Что сделано
- поддержка параллельного .then() (который не chaining) (т.е. к Promise в реализации)
- поддержка параллельного .then() к .then() (т.е. к Thenable в реализации)
- поддержка chaining-а .then() (т.е. к Promise в реализации)
- поддержка chaining-а .then() у .then() (т.е. к Thenable в реализации)
- поддержка возврата как полифилла, так и значения внутри функций передаваемых в .then()

# Проблемы и что не успела сделать
Не сделанные вещи можно посмотреть в коде по ключевому слову TODO. Ниже - постаралась пояснить подробнее:

- Thenable и Promise очень похожи (имеют схожие поля), но не догадалась, как их совместить
- Не очень ясно, когда должны срабатывать onReject функции в случае .then() к не-полифиллу
- Не полностью сделала перехватывание исключений в не первичном полифилле (не понятно, что делать в случае throw внутри onResolve, onReject)
- Не успела добавить валидацию
- Не сделала проверку существования нативного Promise (если мы, например, в ES6)
- Тесты только ручные (при запуске файла promise.js)

# Описание
1. Promise(action) создает промис, в котором сразу запускается action функция
2. then(onReject, onResolve) промиса добавляет колбеки на onResolve, onReject и дополнительно создает Thenable() объект
3. Thenable() - объект, у которого нет "своей функции", но у него есть then() с такой же семантикой, как у промиса.
Также у Thenable есть метод execute, который вызывается при получении результата родительского промиса/thenable.
В кратце:
- then() у Thenable является методом связывания Thenable объектов.
- execute() запускает поддерево связанных объектов.

